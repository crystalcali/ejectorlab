# -*- coding: utf-8 -*-
"""Eject (5).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DUaN8G37evn5mxbZ3gP82dM6DuBk251-
"""

from .preos import Molecule, preos

import math
import concurrent.futures
import numpy as np


class ThermodynamicCalculator:
    def __init__(self, k):
        self.k = k
        self.lambda_max = math.sqrt((self.k + 1) / (self.k - 1))
        self.Pi_crit = (2 / (self.k + 1)) ** (self.k / (self.k - 1))  # Критическое давление
        self.epsilon_crit = (1 - (self.k - 1) / (self.k + 1)) ** (1 / (self.k - 1))
        # Словарь методов для вычисления лямбда через различные функции
        self.lambda_methods = {
            'lambda': self.set_lambda,
            'tau': self.calculate_lambda_from_tau,
            'pr': self.calculate_lambda_from_pr,
            'epsilon': self.calculate_lambda_from_epsilon,
            'qf': self.calculate_lambda_from_qf
        }

    def set_lambda(self, value):
        self.lambda_value = value

    def calculate_lambda(self, function_name, value):
        if function_name in self.lambda_methods:
            self.lambda_methods[function_name](value)
        else:
            raise ValueError(f"Method for {function_name} not found")

        # После вычисления лямбда, вычисляем все остальные функции
        self.calculate_all_functions()

    def calculate_lambda_from_tau(self, tau):
        self.lambda_value = math.sqrt(((self.k + 1) / (self.k - 1)) * (1 - tau))

    def calculate_lambda_from_pr(self, pr):
        if pr is None:
            raise ValueError("Could not find a valid value for pr")
        tau = pr ** ((self.k - 1) / self.k)
        self.calculate_lambda_from_tau(tau)

    def calculate_lambda_from_epsilon(self, epsilon):
        pr = epsilon ** self.k
        self.calculate_lambda_from_pr(pr)

    def calculate_lambda_from_qf(self, qf, accuracy=1e-5):
        self.qf = qf
        if qf >= 1:
            self.lambda_value = 1
        else:
            pr = self.find_pr_by_qf(qf, accuracy)
            if pr is None:
                raise ValueError("Could not find a valid value for pr matching the given qf")
            self.calculate_lambda_from_pr(pr)

    def q_func(self, P):
        return self.lambda_max * (P / self.Pi_crit) ** (1 / self.k) * math.sqrt(1 - ((P) ** ((self.k - 1) / self.k)))

    def find_pr_by_qf(self, qr, initial_step=0.001, tolerance=1e-3):
        def search_forward():
            P = 0
            step = initial_step
            previous_P, previous_q_value = P, self.q_func(P)
            while P <= 1:
                q_value = self.q_func(P)
                #print(f"Forward: P={P}, q_value={q_value}")  # Отладочное сообщение
                if q_value >= qr:
                    if abs(previous_q_value - qr) < abs(q_value - qr):
                        return previous_P
                    else:
                        return P
                previous_P, previous_q_value = P, q_value
                P += step
            return None

        def search_backward():
            P = 1
            step = initial_step
            previous_P, previous_q_value = P, self.q_func(P)
            while P >= 0:
                q_value = self.q_func(P)
                #print(f"Backward: P={P}, q_value={q_value}")  # Отладочное сообщение
                if q_value >= qr:
                    if abs(previous_q_value - qr) < abs(q_value - qr):
                        return previous_P
                    else:
                        return P
                previous_P, previous_q_value = P, q_value
                P -= step
            return None

        with concurrent.futures.ThreadPoolExecutor() as executor:
            future_forward = executor.submit(search_forward)
            future_backward = executor.submit(search_backward)

            result_forward = future_forward.result()
            result_backward = future_backward.result()

        valid_results = [p for p in [result_forward, result_backward] if p is not None]
        #print(f"Valid results: {valid_results}")  # Отладочное сообщение
        return max(valid_results) if valid_results else None


    def calculate_all_functions(self):
        self.tau = 1 - ((self.k - 1) / (self.k + 1)) * (self.lambda_value ** 2)
        self.pr = self.tau ** (self.k / (self.k - 1))
        self.epsilon = self.pr ** (1 / self.k)
        self.qf = self.lambda_max * ((self.pr / self.Pi_crit) ** (1 / self.k)) * math.sqrt(1 - (self.pr) ** ((self.k - 1) / self.k))

    def get_results(self):
        return {
            'lambda': self.lambda_value,
            'tau': self.tau,
            'pr': self.pr,
            'epsilon': self.epsilon,
            'qf': self.qf
        }

#k = 1.3
#calculator = ThermodynamicCalculator(k)
#qf_value = 0.49  # Примерное значение qf
#calculator.calculate_lambda('qf', qf_value)
#results = calculator.get_results()
#print("Результаты для qf:")
#print(results)



class CalcEjector:
    def __init__(self, Gr, Gi, Pr, Pi, Tr, Ti, Rr, Ri, kr, ki, state_model_r, state_model_i):
        # Инициализация переменных
        self.Gr = Gr
        self.Gi = Gi
        self.Pr = Pr
        self.Pi = Pi
        self.Tr = Tr
        self.Ti = Ti
        self.u = Gi / Gr
        self.Rr = Rr
        self.Ri = Ri
        self.kr = kr
        self.ki = ki
        self.cpr = kr / (kr - 1) * self.Rr
        self.cpi = ki / (ki - 1) * self.Ri
        self.O = Ti / Tr
        self.state_model_r = state_model_r
        self.state_model_i = state_model_i

        # Определение модели состояния для r
        if self.state_model_r == "ideal gas":
            self.vr = self.Rr * self.Tr / self.Pr  # Удельный объем
        elif self.state_model_r == "peng robinson":
            molecule_r = preos.Molecule("example", Tc=190.65, Pc=45.8, omega=0.013)  # метан !!! ДОБАВИТЬ СМЕНУ ПАРАМЕТРОВ ДЛЯ КАЖДОГО ВЕЩЕСТВА!!!
            self.preos_result_r = preos.preos(molecule_r, self.Tr, self.Pr / 101325, plotcubic=True, printresults=True)
            density_r = self.preos_result_r["density(mol/m3)"]
            self.z_r = self.preos_result_r["compressibility_factor"]
            self.vr = 1 / density_r

        # Определение модели состояния для i
        if self.state_model_i == "ideal gas":
            self.vi = self.Ri * self.Ti / self.Pi
        elif self.state_model_i == "peng robinson":
            molecule_i = preos.Molecule("example", Tc=190.65, Pc=45.8, omega=0.013)
            preos_result_i = preos.preos(molecule_i, self.Ti, self.Pi / 101325, plotcubic=False, printresults=False)
            density_i = preos_result_i["density(mol/m3)"]
            self.vi = 1 / density_i

        self.kc = ((kr / (kr - 1)) + self.u * (ki / (ki - 1)) * (Ri / Rr)) / ((1 / (kr - 1)) + self.u * (1 / (ki - 1)) * (Ri / Rr))
        self.Rc = (Rr + self.u * Ri) / (1 + self.u)
        self.cpc = (self.cpr + self.u * self.cpi) / (1 + self.u)

        # П* !!!! Добавить для r, i, c. Перенести все газ. функции в __init__ из calculate_rel_mix_pressure
        self.Pr_crit = (1 - (self.kr - 1) / (self.kr + 1)) ** (self.kr / (self.kr - 1))
        self.Pr_crit_i = (1 - (self.ki - 1) / (self.ki + 1)) ** (self.ki / (self.ki - 1))
        self.Pr_crit_c = (1 - (self.kc - 1) / (self.kc + 1)) ** (self.kc / (self.kc - 1))

        # a*
        self.a_crit_r = math.sqrt(2 * (kr / (kr + 1)) * Pr * self.vr)
        self.a_crit_i = math.sqrt(2 * (ki / (ki + 1)) * Pi * self.vi)
        self.a_crit_c = math.sqrt((self.a_crit_r ** 2 + self.u * (self.a_crit_i ** 2)) / (1 + self.u))

    # ... остальной код класса ...

    #Расчет критического площади и диаметра критического сечения
    def calculate_critical_area(self):
        c_koef =  math.sqrt(self.kr * ( 2 / ( self.kr + 1 )) ** ( (self.kr+1)/(self.kr-1)))
        multiplier_1 = math.sqrt( 1 / ( self.Rr * self.Tr ))
        multiplier_2 = self.Pr * c_koef
        self.critical_area = self.Gr / ( multiplier_2 * multiplier_1)
        self.critical_diameter = math.sqrt( 4 * self.critical_area / math.pi)
        return self.critical_area, self.critical_diameter

    def calculate_qn2(self, Pm, qc3, qrn):
        #ДОДЕЛАТЬ!!!
        qn2 = self.u / ((1+self.u)*(self.a_crit_c/self.a_crit_i)*(self.ki/self.kc)*(self.Pr_crit_i/self.Pr_crit_c)*(self.Pi/Pm)*(1/qc3) - (self.a_crit_r/self.a_crit_i)*(self.ki/self.kr)*(self.Pr_crit_i/self.Pr_crit)*(self.Pi/self.Pr)*(1/qrn))
        #qn2 = ( self.u * math.sqrt(self.O) ) / (( self.Pi / Pm ) * ( ( 1 + self.u * math.sqrt(self.O) ) / qc3 ) - (self.Pi/self.Pr) * (1 / qrn) )
        return qn2

    def calculate_rel_mix_pressure(self, Pm, q_c_3):
        # pc/pi = Pmri
        self.fi1 = 0.95
        self.fi2 = 0.975
        self.fi3 = 0.9
        self.fi4 = 0.925

        self.K1 = self.fi1 * self.fi2 * self.fi3
        self.K2 = self.fi2 * self.fi3 * self.fi4

        #Поиск для r.n.
        self.pr_r_n = self.Pi / self.Pr
        calc_r_n = ThermodynamicCalculator(self.kr)
        print(f"self.pr_r_n: {self.pr_r_n}")
        try:
            calc_r_n.calculate_lambda('pr', self.pr_r_n)
            results_r_n = calc_r_n.get_results()
            print("Результаты для calc_r_n :")
            print(results_r_n)
        except ValueError as e:
            print(e)
        self.lambda_r_n = results_r_n['lambda']
        self.q_r_n = results_r_n['qf']


        #Поиск для n.2
        print(f"self.q_r_n: {self.q_r_n}")
        print(f"self.pr_r_n: {self.pr_r_n}")
        print(f"Pm: {Pm}")
        self.q_n_2 = self.calculate_qn2(Pm, q_c_3, self.q_r_n)
        calc_n_2 = ThermodynamicCalculator(self.kr)
        print(f"q_n_2: {self.q_n_2}")
        try:
            calc_n_2.calculate_lambda('qf', self.q_n_2)
            results_n_2 = calc_n_2 .get_results()
            print("Результаты для calc_n_2 :")
            print(results_n_2)
        except ValueError as e:
            print(e)
        self.lambda_n_2 = results_n_2['lambda']
        self.pr_n_2 = results_n_2['pr']


        #Поиск для c.3
        calc_c_3 = ThermodynamicCalculator(self.kr)
        try:
            calc_c_3.calculate_lambda('qf', q_c_3)
            results_c_3 = calc_c_3.get_results()
            #print("Результаты для calc_c_3 :")
            #print(results_c_3)
        except ValueError as e:
            print(e)
        self.lambda_c_3 = results_c_3['lambda']
        self.pr_c_3 = results_c_3['pr']


        #П*

        #u * sqrtO
        self.u_sq_o = self.u * math.sqrt(self.O)
        #print(f'u_sq_o: {self.u_sq_o}') #Отладочное сообщение
        #print(f'Pr_crit: {self.Pr_crit}') #Отладочное сообщение

        n1 = self.K1 * self.lambda_r_n
        n2 = self.fi3 * (self.pr_r_n/self.Pr_crit) * (1 / (self.kr * self.q_r_n))
        n3 = self.u * (self.K2 * self.lambda_n_2 + self.fi3 * (self.pr_n_2/self.Pr_crit_i)*(1 / (self.ki * self.q_n_2)))
        n4 = self.lambda_c_3 * (1 + self.u)
        numerator = (self.a_crit_r/self.a_crit_c) * n1 + (self.a_crit_r/self.a_crit_c)* n2 + ((self.a_crit_i/self.a_crit_c))*n3 - n4

        denominator = self.fi3 * self.pr_c_3 * ((self.a_crit_r/self.a_crit_c)*(self.pr_r_n/self.Pr_crit) * (1/(self.kr * self.q_r_n)) + self.u*(self.a_crit_i/self.a_crit_c) * (1 / (self.Pr_crit_i * self.ki * self.q_n_2)))
        #print(f'numerator: {numerator}') #Отладочное сообщение
        #print(f'denominator: {denominator}') #Отладочное сообщение
        self.pmri = numerator / denominator
        return self.pmri

    def calculate_second_critical_mode(self):
        self.pr_r_n = (self.Pi / self.Pr) * self.Pr_crit_i
        calc_r_n = ThermodynamicCalculator(self.kr)
        try:
            calc_r_n.calculate_lambda('pr', self.pr_r_n)
            results_r_n = calc_r_n.get_results()
            #print("Результаты для расчета С :")
            #print(results_r_n)
        except ValueError as e:
            print(e)
        self.qps = results_r_n['qf']

        self.C_const = ((1 + self.u)*(self.a_crit_c/self.a_crit_i)*(self.ki/self.kc)*(self.Pr_crit_i /self.Pr_crit_c)) / ((self.a_crit_r/self.a_crit_i)*(self.ki/self.kr)*(self.Pr_crit_i/self.Pr_crit)*(self.Pi/self.Pr)*(1/self.qps) + self.u)
        #self.C_const = ( 1 + self.u * math.sqrt(self.O) ) / ( ( self.Pi/self.Pr) * (1/self.qps) + self.u * math.sqrt(self.O))
        return self.C_const

    def calculate_second_section(self):
        self.f2 =  (self.critical_area/self.q_r_n) + self.critical_area *(self.kr/self.ki)* (self.Pr/self.Pi)*(self.a_crit_i/self.a_crit_r)*(self.Pr_crit/self.Pr_crit_i)*(self.u/self.q_n_2)
        self.d2 = math.sqrt(4*self.f2/math.pi)
        return self.f2, self.d2

    def calc_pc(self, coef_p, qc3, psa_pr):
            return coef_p * self.Pi * psa_pr

    def optimize_psa(self, lambda_values):
            calculator = ThermodynamicCalculator(self.kr)
            psa_intersections = []

            for lambdaf in lambda_values:
                try:
                    calculator.calculate_lambda('lambda', lambdaf)
                    results = calculator.get_results()
                except ValueError as e:
                    print(e)
                    psa_intersections.append(None)
                    continue

                qc3 = results['qf']
                psa_pr = self.calculate_second_critical_mode() / qc3
                Pc_calc = psa_pr * self.Pi
                psa_pr_calc = self.calculate_rel_mix_pressure(Pc_calc, qc3)

                if psa_pr <= psa_pr_calc:
                    psa_intersections.append(psa_pr)
                else:
                # Define two points for linear interpolation
                    x_i1 = 0.7
                    x_i2 = 0.9
                    psa_i1 = self.calculate_rel_mix_pressure(self.calc_pc(x_i1, qc3, psa_pr), qc3)
                    psa_i2 = self.calculate_rel_mix_pressure(self.calc_pc(x_i2, qc3, psa_pr), qc3)

                    # Linear interpolation
                    a = (psa_i2 - psa_i1) / (x_i2 - x_i1)
                    b = psa_i2 - a * x_i2
                    coef_p_opt = b / (psa_pr - a)

                    psa = self.calculate_rel_mix_pressure(self.calc_pc(coef_p_opt, qc3, psa_pr), qc3)
                    psa_intersections.append(psa)

            # Filter out None values
            valid_indices = [i for i, val in enumerate(psa_intersections) if val is not None]
            valid_lambda_values = [lambda_values[i] for i in valid_indices]
            valid_psa_intersections = [psa_intersections[i] for i in valid_indices]



            # Find the maximum psa and corresponding lambda
            if valid_psa_intersections:
                max_psa = max(valid_psa_intersections)
                max_lambda = valid_lambda_values[np.argmax(valid_psa_intersections)]
            else:
                max_psa = None
                max_lambda = None

            pr_r_n = self.Pi / self.Pr
            try:
                calculator.calculate_lambda('pr', pr_r_n)
                results_r_n = calculator.get_results()
                #print("Результаты для calc_r_n :")
                #print(results_r_n)
            except ValueError as e:
                print(e)
                results_r_n = None

            lambda_r_n = results_r_n['lambda']
            qf_r_n = results_r_n['qf']

            f1, d1 = self.calculate_critical_area()
            frs = f1 / qf_r_n
            drs = math.sqrt(4 * frs / math.pi)
            f2, d2 = self.calculate_second_section() 
            aconst = 0.08 #эксперементальная постоянная
            if self.u <= 0.5:
                lc1 = (math.sqrt(0.083+0.76*self.u) - 0.29)*(drs/aconst)
                d4 = 3.4*drs*math.sqrt(0.083+0.76*self.u)
                print(f"Диаметр свободной струи:{d4}")
            else:
                lc1 = ((0.37 + self.u)/(4.4*aconst))*drs
                d4 = 1.55*drs*(1+self.u)
                print(f"Диаметр свободной струи:{d4}")
            if d2 > d4:
                lrs = lc1 #длинна от сопла до начала камеры смешения
            else:
                lc2 = (d4-d2)/2
                lrs = lc1+lc2
            
            lk = 10 * d2
            w = 20
            vc = self.Rc*self.Tr/(max_psa*self.Pi)
            fcd = self.Gr*(1 + self.u)/(w/vc)
            dcd = math.sqrt(4 * fcd / math.pi)
            ld = 7 * (dcd - d2)
            print(f"Lambda out: {lambda_r_n}")

            return {
                "Максимальная степень сжатия Pc/Pi": max_psa,
                "Скорость потока на выходе из камеры смешения w м/сек": max_lambda * self.a_crit_r,
                #"valid_lambda_values": valid_lambda_values,
                #"valid_psa_intersections": valid_psa_intersections,
                #"critical_area": f1,
                "Диаметр критического сечения dcr мм²": d1 * 1000,
                #"work_nozzle_out_section_area": frs,
                "Диаметр выхода сопла Лаваля drs мм²": drs * 1000,
                #"second_section_area": f2,
                "Диаметр камеры смешения d2 мм²": d2 * 1000,
                "Расстояние между выходом сопла и началом камеры смешения lrs мм": lrs* 1000,
                "Длинна камеры смешения lk мм": lk* 1000,
                "Длинна дифузора ld": ld* 1000,
                "Диаметр диффузора в кнце dout мм²": dcd* 1000,
                "Давление смешенного потока Pc Па": max_psa * self.Pi
            }
